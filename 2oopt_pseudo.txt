/*I still need to figure out how to decide which vertices are candidates
for swap unless we simply wish to iterate through all of them.

functions: we need a distance(), routeLength(), findAnyroute(), input(), output(), findCandidates(), others???
*/

/*We are still using structs for C but it may be beneficial to modify this.*/
//struct to hold city info
struct vertex{
	char id;
	int x;
	int y;
}

/*-----------------------CLASSES-----------------*/

class city{
	public:
		bool isCandidate();
		int getX();
		int getY();
		// int getLocation();??????/
	private:
		int x;
		int y;
		bool candidate;
}

class route{
	public:
		int getDistance();
		void addCity();
		city* getCity(int)

	private:
		vector<city*> cities();
}

int main(){

	/*
		start with some route to operate swaps upon
		this can literally read input in order and make that the initial route.
		we are assuming the graph is initially complete and are looking to define
		a route as a simple graph where every vertex has degree 2
	*/

	vertex* route = findAnyRoute();
	int iter = 0;
	n = num of cities;

	//while designing we can test against the cases she gave us to get desired number of iterations
	while(routeLength(route)/solution > 1.25){
		//considert the distance of the starting route the best
		optimum = routeLength(route);
		//for each pair of cities, perform swaps on them to "uncross any edges"
		for(i = 0; i < n; i++){
			for(j = 0; j < n; j++){
				newRoute = swap(route, i, j);
				//calculate the distance of the new route anmd store if it is an imporvement
				newDistance = routeLength(newRoute);
				if(newDistance < optimum){
					route = newRoute
				}
			}
		}
		
		iter++;
	}
	print(optimum, route);
}

vertex* swap(vertex* E, vertex* i, vertex* j{
	char tmp[];
	for(idx = 0; idx < i; idx++){
		tmp[idx] = E[idx]
	}
	for(idx = k; idx > i-1 j; idx--){
		tmp[i + (k-idx)] = E[i + (k - idx)]
	}
	for(idx = k; idx < E.length(); idx++){
		tmp[idx] = E[idx]	
	}
	return tmp;
})

int routeLength(vertex* route){
	//find distance of route listed in vertex array;
}

findAnyRoute(){
	//find a hamilton cycle? or just some cycle that hits all cities
}

/****************************NEW PSEUDO***************************************/

#include<fstream>
#include<string.h>
#include<vector>
#include<math>

struct city{
	int id;
	int x;
	int y;
}

double? int? distance(city*, city*);
double? int? length(route*);

swap(city*, city*, route*);
int main(){

	/*__________________Get Input_________________*/
	string inputFile = argv[2];

	route = vector<city*>;

	std::ifstream input("inputFile");

	int id, x, y;
	while(input >> id >> x >>y){
		city* newCity = city(id, x, y);
		route.push(newCity*);

	}

	/*___________________Perform 2-Opt______________*/

		//see code link

	/*____________________Write Solution_____________*/
	std::ofstream output(""inputFile"+".tour")
	fprintf("%d\n" route.length(), output);
	for(i in route){
		fprintf("%d %d %d\n", i.id, i.x, i.y, output);
	}
}

double? int? distance(city* a, city* b){
	return sqrt([(b.x-a.x)*(b.x-a.x)] + [(b.y-a.y)*(b.y-a.y)]);
}

double? int? length(route* route){
	int l = 0;
	for(idx = 1; idx < route.size; idx++){
		l += distance(route.at(idx-1), route.at(idx));
	}
	l += distance(route.at(route.size), route.begin());
}

swap(city*, city*){
	//see code link
}